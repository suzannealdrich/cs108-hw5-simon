// CSimonWindow.cp#include "CSimonWindow.h"#include <typeinfo>static int RandomNum(int bound) {	UInt16 value = ::Random();	return value / 65536.0 * bound;}static void Delay(double delayTime) {	::Delay(delayTime * TICKS_PER_SEC, 0);}CSimonWindow::CSimonWindow(LStream *inStream)	: LWindow(inStream) , LListener() {		mGameInProgress = mPlayingSequence = false;}void CSimonWindow::FinishCreateSelf() {	UReanimator::LinkListenerToControls(this, this, this->GetPaneID());		mCaption = (LCaption*) FindPaneByID(STATUS_CAPTION_ID);	Assert_(mCaption);	DoChangeCaption(WELCOME_INDEX);		mBeginButton = (LStdButton*) FindPaneByID(BEGIN_BUTTON_ID);	Assert_(mBeginButton);	mBeginButton->Enable();		mEndButton = (LStdButton*) FindPaneByID(END_BUTTON_ID);	Assert_(mEndButton);	mEndButton->Disable();		LPane* sub;	TArrayIterator<LPane*> iterator = GetSubPanes();		while (iterator.Next(sub)) {		if (typeid(*sub) == typeid(CSimonButton)) {			mSimonPalette.AddItem((CSimonButton*) sub);		}	}}Boolean CSimonWindow::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean	cmdHandled = false;			switch (inCommand) {		case cmd_PlayGame:			DoPlayGame();			cmdHandled = true;			break;					case cmd_EndGame:			DoEndGame();			cmdHandled = true;			break;								default:			cmdHandled = LWindow::ObeyCommand(inCommand, ioParam);			break;	}		return cmdHandled;}void CSimonWindow::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	Char16		&outMark,	Str255		outName){	switch (inCommand) {		case cmd_PlayGame:			outEnabled = !mGameInProgress;			break;					case cmd_EndGame:			outEnabled = mGameInProgress;			break;					default:			LWindow::FindCommandStatus(inCommand, outEnabled,										outUsesMark, outMark, outName);			break;	}}void CSimonWindow::ListenToMessage(MessageT inMessage, void *ioParam) {	if (inMessage == msg_PlayGameClick) {		DoPlayGame();	} 	else 	if (inMessage == msg_EndGameClick) {		DoEndGame();	}	else	if ((inMessage == msg_SimonClick) && mGameInProgress && !mPlayingSequence) {		DoSimonClick((CSimonButton*) ioParam);	}}void CSimonWindow::DoPlayGame() {	mGameInProgress = true;	mBeginButton->Disable();	mEndButton->Enable();	DoPlaySequence();}void CSimonWindow::DoPlaySequence() {	mPlayingSequence = true;	DoChangeCaption(PLAY_SEQUENCE_INDEX);	Delay(DELAY_BEFORE_SEQUENCE);		CSimonButton* randomButton;	mSimonPalette.FetchItemAt(RandomNum(mSimonPalette.GetCount() - 1) + 1, randomButton);	Assert_(randomButton);	mSimonSequence.AddItem(randomButton);		CSimonButton* playButton;	TArrayIterator<CSimonButton*> iterator = mSimonSequence;	while (iterator.Next(playButton)) {		Delay(DELAY_DURING_SEQUENCE);		playButton->SimulateHotSpotClick(0);	}	::FlushEvents(mDownMask, 0);		mUserIndex = 1;	DoChangeCaption(ENTER_SEQUENCE_INDEX);	mPlayingSequence = false;}void CSimonWindow::DoSimonClick(CSimonButton* button) {	CSimonButton* sequenceButton;	mSimonSequence.FetchItemAt(mUserIndex, sequenceButton);	Assert_(sequenceButton);	if (button != sequenceButton) {		Handle sound = ::Get1Resource('snd ', WRONG_ID);		if (sound != NULL) {			::SndPlay(NULL, (SndListHandle)sound, false);			::ReleaseResource(sound);		}		DoEndGame();	} else { 		if (mUserIndex == mSimonSequence.GetCount())  {			DoPlaySequence();		} else {			mUserIndex++;		}	}}void CSimonWindow::DoEndGame() {	mGameInProgress = false;	mBeginButton->Enable();	mEndButton->Disable();	mSimonSequence.RemoveAllItemsAfter(0);	DoChangeCaption(GAME_OVER_INDEX);}void CSimonWindow::DoChangeCaption(ResIDT index) {	Str255 dest;	::GetIndString(dest, STATUS_STRING_ID, index);	mCaption->SetDescriptor(dest);	mCaption->UpdatePort();}